name: Chrome XFCE Desktop VNC (Auto)
on: 
  workflow_dispatch:

jobs:
  chrome-user:
    runs-on: ubuntu-latest
    container:
      image: ubuntu:22.04
      options: --privileged --shm-size=2gb
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Environment
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          apt-get update
          apt-get install -y wget curl git net-tools sudo unzip xz-utils libgbm1 libnss3 libasound2 python3-pip
          
          wget -q https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb
          apt-get install -y ./google-chrome-stable_current_amd64.deb
          rm google-chrome-stable_current_amd64.deb
          apt-get install -y fonts-liberation fonts-noto-color-emoji fontconfig ttf-mscorefonts-installer
          apt-get install -y xvfb x11vnc python3 pulseaudio dbus-x11 xfce4 xfce4-goodies xfce4-terminal
          echo "ttf-mscorefonts-installer msttcorefonts/accepted-mscorefonts-eula select true" | debconf-set-selections
          fc-cache -f -v
          git clone https://github.com/novnc/noVNC.git /opt/noVNC
          git clone https://github.com/novnc/websockify /opt/noVNC/utils/websockify
          ln -s /opt/noVNC/vnc.html /opt/noVNC/index.html
          chmod -R 777 /opt/noVNC

          pip3 install playwright tf-playwright-stealth numpy cbor2
          playwright install-deps chromium


      - name: Setup User
        run: |
          useradd -m -s /bin/bash appuser
          echo "appuser ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers
          
          su appuser -c "mkdir -p /home/appuser/Downloads"
          su appuser -c "mkdir -p /home/appuser/Desktop"


      - name: Start XFCE Desktop
        run: |
          service dbus start || true
  
          cat <<EOF > /home/appuser/run_desktop.sh
          #!/bin/bash
          export DISPLAY=:99
          export HOME=/home/appuser
          Xvfb :99 -screen 0 1440x900x24 &
          sleep 2
          export XFCE_PANEL_MIGRATE_DEFAULT=true
          startxfce4 &
          x11vnc -display :99 -forever -bg -noxdamage
          /opt/noVNC/utils/novnc_proxy --vnc localhost:5900 --listen 6080 &
          EOF
          
          chmod +x /home/appuser/run_desktop.sh
          su appuser -c "/home/appuser/run_desktop.sh"
          
          sleep 5
          su appuser -c "export DISPLAY=:99; xset s off; xset -dpms; xset s noblank"


      - name: Cloudflare Tunnel
        run: |
          curl -L --output cloudflared.deb https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
          dpkg -i cloudflared.deb
          cloudflared tunnel --url http://localhost:6080 > tunnel.log 2>&1 &
          
          echo "Waiting for Tunnel..."
          for i in $(seq 1 10); do
            TUNNEL_URL=$(grep -oE "https://[a-zA-Z0-9-]+\.trycloudflare\.com" tunnel.log | head -1)
            if [ -n "$TUNNEL_URL" ]; then
                echo "Found Tunnel URL: $TUNNEL_URL"
                break
            fi
            sleep 1
          done
          
          echo "=========================================================="
          echo "üñ•Ô∏è  XFCE Desktop Ready!"
          echo "üîó  VNC Link: $TUNNEL_URL/vnc.html?autoconnect=true"
          echo "=========================================================="
      
      - name: Launch Chrome
        run: |
          cat <<'EOF' > /home/appuser/get_ipa.py
          import time
          import os
          import json
          import re

          from playwright.sync_api import sync_playwright
          from playwright_stealth import stealth_sync
          import cbor2


          USER_DATA_DIR = '/home/appuser/.config/google-chrome'
          EXECUTABLE_PATH = '/usr/bin/google-chrome-stable'
          base_url = "https://decrypt.day/app/id1489932710"

          def cbor_to_list(b: bytes):
              hex_str = b.hex()
              return [int(hex_str[i:i+2], 16) for i in range(0, len(hex_str), 2)]

          with sync_playwright() as p:
              print("[-] Setup Chrome")
              
              # pr launch_persistent_context
              browser = p.chromium.launch(
                  #user_data_dir=USER_DATA_DIR,
                  executable_path=EXECUTABLE_PATH,
                  headless=False,
                  args=[
                      '--no-sandbox',
                      '--disable-gpu',
                      '--disable-blink-features=AutomationControlled', 
                      '--start-maximized',
                      # '--no-first-run',
                      # '--no-default-browser-check',
                      # '--disable-dev-shm-usage',
                  ],
                  ignore_default_args=["--enable-automation"],
              )
              
              print("Setup context")
              context = browser.new_context()
              context.add_init_script("""
                  Object.defineProperty(navigator, 'webdriver', {
                      get: () => undefined
                  });
              """)

              print("[-] Open app info page")
              page = context.new_page()
              stealth_sync(page)
              page.goto(base_url, timeout=60000)

              page.wait_for_load_state("domcontentloaded")
              
              if "Just a moment" in page.title() or "Cloudflare" in page.title() or "cf" in page.url:
                  time.sleep(20)
                  if "Just a moment" in page.title() or "Cloudflare" in page.title() or "cf" in page.url:
                      print("[x] Warning: Cloudflare blocked us. Quit.")
                      exit(1)
              
              page.wait_for_load_state("domcontentloaded")


              # fetch download link via JS fetch
              payload = cbor2.dumps({
                  "appId": "cl9se40tq00abdofwqtgov0zs",
                  "version": "6.2.0",
                  "isPremier": cbor2.undefined,
              })
              payload_text = ",".join(map(str,cbor_to_list(payload)))

              result = page.evaluate("""
                  async () => {
                      const formData = new FormData();
                      formData.append('data', '163,101,97,112,112,73,100,120,25,99,108,57,115,101,52,48,116,113,48,48,97,98,100,111,102,119,113,116,103,111,118,48,122,115,103,118,101,114,115,105,111,110,101,54,46,50,46,48,105,105,115,80,114,101,109,105,101,114,247');

                      const resp = await fetch('$BASE_PAGE_URL$?/files', {
                          method: 'POST',
                          body: formData,
                      });
                      return await resp.text();
                  }
              """.replace("$BASE_PAGE_URL$", base_url))
              # print(type(result))
              # print(result)
              assert isinstance(result, str), f"Invalid response type: {type(result)}"

              try:
                  download_page_req = json.loads(result)
                  assert download_page_req.get("type") == "success", f"Failed when request download path: {download_page_req}"
                  dl_page_details: list = json.loads(download_page_req.get("data"))
              except json.JSONDecodeError as e:
                  raise ValueError(f"Invalid JSON: {e}\nRequest result: {result}")
              
              free_dl_path = ""
              try:
                  free_dl_path = dl_page_details[dl_page_details.index("gofile.io") - 3]
              except IndexError:
                  # fallback
                  print("[!] Fallback: scanning for valid download path...")
                  for e in dl_page_details:
                      if not (isinstance(e, str) and len(e) == 21):
                          continue
                      free_dl_path = e
                      break
              
              # goto download page
              if not free_dl_path:
                  raise ValueError(f"Cannot get download page path. Request: {download_page_req}")

              download_page_url = f"{base_url}/dl/{free_dl_path}"
              print(f"[-] Download Page: {download_page_url}")

              dl_page = context.new_page()
              stealth_sync(dl_page)
              dl_page.goto(download_page_url, referer=base_url)

              btn = dl_page.locator("button.btn-download").filter(has_text="Get download link")
              btn.click()
            
              print("[-] Trying to fetch download link")
              time.sleep(10)

              btn = dl_page.locator("button.btn-download").filter(has_text="Download")
              print("[-] Preparing download")

              with dl_page.expect_download() as download_info:
                  btn.click()

              download = download_info.value
              semantic_version = r'\d+\.\d+\.\d+'
              match = re.search(semantic_version, download.suggested_filename)
              if match:
                  version = match.group()
                  print(f"[-] Version: {version}")
              else:
                  version = f"unknown_{download.suggested_filename}"
                  print(f"[!] Unable find semantic version: {version}")

              download_path = os.path.join("/home/appuser/Downloads", f"{version}.ipa")
              download.save_as(download_path)
              print(f"[-] File saved at: {download_path}")
              print("[-] Exited")
              
          EOF

          cat <<EOF > /home/appuser/run_bot.sh
          #!/bin/bash
          export DISPLAY=:99
          export HOME=/home/appuser
          export LIBGL_ALWAYS_SOFTWARE=1
              
          #nohup python3 -u /home/appuser/get_ipa.py > /home/appuser/bot.log 2>&1 &
          python3 -u /home/appuser/get_ipa.py
          EOF
          
          echo "ü§ñ Script running..."
          chown appuser:appuser /home/appuser/get_ipa.py
          chmod +x /home/appuser/get_ipa.py

          touch /home/appuser/bot.log
          chmod 666 /home/appuser/bot.log
          chmod +x /home/appuser/run_bot.sh
          
          su appuser -c "/home/appuser/run_bot.sh"
          
      - name: Monitor Download
        timeout-minutes: 10
        run: |
          TARGET_DIR="/home/appuser/Downloads"
          MAX_SIZE_MB=100
          
          echo "Starting monitoring loop in $TARGET_DIR"
          
          while true; do
            FILE=$(find "$TARGET_DIR" -name "*.ipa" -print -quit)
            
            if [ -n "$FILE" ]; then
              BASENAME=$(basename "$FILE")
              
              if [ -f "${FILE}.crdownload" ]; then
                 echo "‚è≥ Downloading (crdownload present): $BASENAME..."
              else
                 SIZE_MB=$(du -m "$FILE" | cut -f1)
                 
                 if [ "$SIZE_MB" -le "$MAX_SIZE_MB" ]; then
                   echo "‚ö†Ô∏è Found $BASENAME ($SIZE_MB MB), waiting for full file..."
                 else
                   echo "‚úÖ Success: $BASENAME ($SIZE_MB MB)"
                   break
                 fi
              fi
            else
               echo "Waiting for download..."
            fi
            sleep 5
          done
          
          echo "Download confirmed."

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: download_ipa
          path: /home/appuser/Downloads/*.ipa
